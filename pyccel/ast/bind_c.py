# -*- coding: utf-8 -*-
#------------------------------------------------------------------------------------------#
# This file is part of Pyccel which is released under MIT License. See the LICENSE file or #
# go to https://github.com/pyccel/pyccel/blob/devel/LICENSE for full license details.      #
#------------------------------------------------------------------------------------------#
"""
Module describing all elements of the AST needed to represent elements which appear in a Fortran-C binding
file.
"""
from functools import cache

from pyccel.ast.basic import PyccelAstNode, TypedAstNode
from pyccel.ast.core import Module, Deallocate
from pyccel.ast.core import FunctionDef, ClassDef
from pyccel.ast.core import FunctionDefArgument, FunctionDefResult
from pyccel.ast.datatypes import FixedSizeType, PythonNativeInt, InhomogeneousTupleType
from pyccel.ast.datatypes import StringType
from pyccel.ast.internals import PyccelFunction
from pyccel.ast.literals import LiteralInteger
from pyccel.ast.variable import Variable
from pyccel.errors.errors     import Errors
from pyccel.utilities.metaclasses import Singleton

errors = Errors()

__all__ = (
    'BindCArrayType',
    'BindCArrayVariable',
    'BindCClassDef',
    'BindCClassProperty',
    'BindCFunctionDef',
    'BindCModule',
    'BindCModuleVariable',
    'BindCPointer',
    'BindCSizeOf',
    'BindCVariable',
    'CLocFunc',
    'C_F_Pointer',
    'C_NULL_CHAR',
    'DeallocatePointer',
    'c_malloc',
)

# =======================================================================================
#                                    Datatypes
# =======================================================================================

class BindCPointer(FixedSizeType, metaclass = Singleton):
    """
    Datatype representing a C pointer in Fortran.

    Datatype representing a C pointer in Fortran. This data type is defined
    in the iso_c_binding module.
    """
    __slots__ = ()
    _name = 'bindcpointer'

class BindCArrayType:
    """
    Datatype for a tuple containing all the information necessary to describe an array.

    Datatype for a tuple containing a pointer to array data and integers describing their
    shape and strides.
    """
    __slots__ = ()
    _name = 'BindCArrayType'

    @classmethod
    @cache
    def get_new(cls, rank, has_strides):
        """
        Get the parametrised BindCArrayType subclass.

        Get the parametrised BindCArrayType subclass.

        Parameters
        ----------
        rank : int
            The rank of the array being described.
        has_strides : bool
            Indicates whether strides are used to describe the array.
        """
        shape_types = (PythonNativeInt(),)*rank
        stride_types = (PythonNativeInt(),)*rank*has_strides
        name = 'BindCArray{rank}DType'
        if has_strides:
            name += '_strided'
        super_class_instance = InhomogeneousTupleType.get_new(BindCPointer(), *shape_types, *stride_types)
        return type(name, (type(super_class_instance), BindCArrayType),
                    {})()

# =======================================================================================
#                                   Wrapper classes
# =======================================================================================


class BindCFunctionDef(FunctionDef):
    """
    Represents the definition of a C-compatible function.

    Contains the C-compatible version of the function which is
    used for the wrapper.
    As compared to a normal FunctionDef, this version contains
    arguments for the shape of arrays. It should be generated by
    calling `codegen.wrapper.FortranToCWrapper.wrap`.

    Parameters
    ----------
    *args : list
        See FunctionDef.

    original_function : FunctionDef
        The function from which the C-compatible version was created.

    **kwargs : dict
        See FunctionDef.

    See Also
    --------
    pyccel.ast.core.FunctionDef
        The class from which BindCFunctionDef inherits which contains all
        details about the args and kwargs.
    """
    __slots__ = ('_original_function',)
    _attribute_nodes = (*FunctionDef._attribute_nodes, '_original_function')

    def __init__(self, *args, original_function, **kwargs):
        self._original_function = original_function
        super().__init__(*args, **kwargs)
        assert self.name == self.name.lower()
        assert all(isinstance(a, FunctionDefArgument) for a in self._arguments)

    @property
    def original_function(self):
        """
        The function which is wrapped by this BindCFunctionDef.

        The original function which would be printed in pure Fortran which is not
        compatible with C.
        """
        return self._original_function

    def rename(self, newname):
        """
        Rename the FunctionDef name->newname.

        Rename the FunctionDef name->newname.

        Parameters
        ----------
        newname : str
            New name for the FunctionDef.
        """
        assert newname == newname.lower()
        self._name = newname

# =======================================================================================

class BindCVariable(Variable):
    """
    A wrapper linking the new C-compatible variable to the original variable.

    A wrapper linking the new C-compatible variable to the variable that is accessible
    via this information. This object is a variable which mimics the new variable so
    it can be used in some of the same contexts but the underlying variables should be
    extracted before manipulating them.

    Parameters
    ----------
    new_var : Variable
        The new C-compatible variable.
    original_var : Variable
        The original variable in the target language.
    """
    __slots__ = ('_new_var', '_original_var')
    _attribute_nodes = Variable._attribute_nodes + ('_new_var', '_original_var')

    def __init__(self, new_var, original_var):
        self._new_var = new_var
        self._original_var = original_var
        super().__init__(new_var.class_type, new_var.name,
                    memory_handling = new_var.memory_handling,
                    is_optional = new_var.is_optional,
                    shape = new_var.shape)

    @property
    def new_var(self):
        """
        The new C-compatible variable.

        The new C-compatible variable.
        """
        return self._new_var

    @property
    def original_var(self):
        """
        The original variable in the target language.

        The original variable from the target language that was wrapped.
        """
        return self._original_var

# =======================================================================================
class BindCModule(Module):
    """
    Represents a Module which only contains functions compatible with C.

    Represents a Module which provides the C-Fortran interface to another module.
    Both functions and module variables are wrapped in order to be compatible with
    C.

    Parameters
    ----------
    *args : tuple
        See `pyccel.ast.core.Module`.

    original_module : Module
        The Module being wrapped.

    variable_wrappers : list of BindCFunctionDef
        A list containing all the functions which expose module variables to C.

    removed_functions : list of FunctionDef
        A list of any functions which weren't translated to BindCFunctionDef
        objects (e.g. private functions).

    **kwargs : dict
        See `pyccel.ast.core.Module`.

    See Also
    --------
    pyccel.ast.core.Module
        The class from which BindCModule inherits which contains all details
        about the args and kwargs.
    """
    __slots__ = ('_orig_mod','_variable_wrappers', '_removed_functions')
    _attribute_nodes = Module._attribute_nodes + ('_orig_mod','_variable_wrappers', '_removed_functions')

    def __init__(self, *args, original_module, variable_wrappers = (), removed_functions = None, **kwargs):
        self._orig_mod = original_module
        self._variable_wrappers = variable_wrappers
        self._removed_functions = removed_functions
        super().__init__(*args, **kwargs)

    @property
    def original_module(self):
        """
        The module which was wrapped.

        The original module for which this object provides the C-Fortran interface.
        """
        return self._orig_mod

    @property
    def variable_wrappers(self):
        """
        Get the wrappers which expose module variables to C.

        Get a list containing all the BindCFunctionDefs which expose module variables to C.
        """
        return self._variable_wrappers

    @property
    def removed_functions(self):
        """
        Get the functions which weren't translated to BindCFunctionDef objects.

        Get a list of the functions which weren't translated to BindCFunctionDef objects.
        This includes private functions and objects for which wrapper support is lacking.
        """
        return self._removed_functions

    @property
    def declarations(self):
        """
        Get the declarations of all module variables.

        In the case of a BindCModule no variables should be declared. Basic variables
        are used directly from the original module and more complex variables require
        wrapper functions.
        """
        return ()

# =======================================================================================

class BindCModuleVariable(Variable):
    """
    A class which wraps a compatible variable from Fortran to make it available in C.

    A class which wraps a compatible module variable from Fortran to make it available
    in C. A compatible variable is a variable which can be exposed to C simply using
    iso_c_binding (i.e. no wrapper function is required).

    Parameters
    ----------
    *args : tuple
        See Variable.

    **kwargs : dict
        See Variable.

    See Also
    --------
    Variable : The super class.
    """
    __slots__ = ()

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

# =======================================================================================

class BindCArrayVariable(Variable):
    """
    A class which wraps an array from Fortran to make it available in C.

    A class which wraps an array from Fortran to make it available in C.

    Parameters
    ----------
    *args : tuple
        See Variable.

    wrapper_function : FunctionDef
        The function which can be used to access the array.

    original_variable : Variable
        The original variable in the Fortran code.

    **kwargs : dict
        See Variable.

    See Also
    --------
    Variable : The super class.
    """
    __slots__ = ('_wrapper_function', '_original_variable')
    _attribute_nodes = ('_wrapper_function', '_original_variable')
    def __init__(self, *args, wrapper_function, original_variable, **kwargs):
        self._original_variable = original_variable
        self._wrapper_function = wrapper_function
        super().__init__(*args, **kwargs)

    @property
    def original_variable(self):
        """
        The original variable in the Fortran code.

        The original variable in the Fortran code. This is important in
        order to access the correct type and other details about the
        Variable.
        """
        return self._original_variable

    @property
    def wrapper_function(self):
        """
        The function which can be used to access the array.

        The function which can be used to access the array. The function
        must return the pointer to the raw data and information about
        the shape.
        """
        return self._wrapper_function

# =======================================================================================

class BindCClassProperty(PyccelAstNode):
    """
    A class which wraps a class attribute.

    A class which wraps a class attribute to make it accessible
    from C. In the future this class will also be used to handle properties of
    classes (i.e. functions marked with the `@property` decorator).

    Parameters
    ----------
    python_name : str
        The name of the attribute/property in the original Python code.
    getter : FunctionDef
        The function which collects the value of the class attribute.
    setter : FunctionDef
        The function which modifies the value of the class attribute.
    class_type : Variable
        The type of the class to which the attribute belongs.
    docstring : LiteralString, optional
        The docstring of the property.
    """
    __slots__ = ('_getter', '_setter', '_python_name', '_docstring', '_class_type')
    _attribute_nodes = ('_getter', '_setter')
    def __init__(self, python_name, getter, setter, class_type, docstring = None):
        assert isinstance(getter, BindCFunctionDef)
        assert isinstance(setter, BindCFunctionDef) or setter is None
        self._python_name = python_name
        self._getter = getter
        self._setter = setter
        self._class_type = class_type
        self._docstring = docstring
        super().__init__()

    @property
    def getter(self):
        """
        The BindCFunctionDef describing the getter function.

        The BindCFunctionDef describing the function which allows the user to collect
        the value of the property.
        """
        return self._getter

    @property
    def setter(self):
        """
        The BindCFunctionDef describing the setter function.

        The BindCFunctionDef describing the function which allows the user to modify
        the value of the property.
        """
        return self._setter

    @property
    def class_type(self):
        """
        The type of the class to which the attribute belongs.

        The type of the class to which the attribute belongs.
        """
        return self._class_type

    @property
    def python_name(self):
        """
        The name of the attribute/property in the original Python code.

        The name of the attribute/property in the original Python code.
        """
        return self._python_name

    @property
    def docstring(self):
        """
        The docstring of the property being wrapped.

        The docstring of the property being wrapped.
        """
        return self._docstring

# =======================================================================================

class BindCClassDef(ClassDef):
    """
    Represents a class which is compatible with C.

    Represents a class which is compatible with C. This means that it stores
    C-compatible versions of class methods and getters and setters for class
    variables.

    Parameters
    ----------
    original_class : ClassDef
        The class being wrapped.

    new_func : BindCFunctionDef
        The function which provides a new instance of the class.

    **kwargs : dict
        See ClassDef.
    """
    __slots__ = ('_original_class', '_new_func')

    def __init__(self, original_class, new_func, **kwargs):
        self._original_class = original_class
        self._new_func = new_func
        super().__init__(original_class.name, scope = original_class.scope, **kwargs)

    @property
    def new_func(self):
        """
        Get the wrapper for `__new__`.

        Get the wrapper for `__new__` which allocates the memory for the class instance.
        """
        return self._new_func

# =======================================================================================
#                                   Utility functions
# =======================================================================================

class CLocFunc(PyccelAstNode):
    """
    Creates a C-compatible pointer to the argument.

    Class representing the iso_c_binding function cloc which returns a valid
    C pointer to the location where an object can be found.

    Parameters
    ----------
    argument : Variable
        The object which should be pointed to.

    result : Variable of dtype BindCPointer
        The variable where the C-compatible pointer should be stored.
    """
    __slots__ = ('_arg', '_result')
    _attribute_nodes = ()

    def __init__(self, argument, result):
        self._arg = argument
        self._result = result
        assert result.dtype is BindCPointer()
        super().__init__()

    @property
    def arg(self):
        """
        Pointer target.

        Object which will be pointed at by the result pointer.
        """
        return self._arg

    @property
    def result(self):
        """
        The variable where the C-compatible pointer should be stored.

        The variable where the C-compatible pointer of dtype BindCPointer
        should be stored.
        """
        return self._result

# =======================================================================================

class C_F_Pointer(PyccelAstNode):
    """
    Creates a Fortran array pointer from a C pointer and size information.

    Represents the iso_c_binding function C_F_Pointer which takes a pointer
    to an object in C (with dtype BindCPointer) and a list of sizes and returns
    a Fortran array pointer.

    Parameters
    ----------
    c_expr : Variable of dtype BindCPointer
        The Variable containing the C pointer.

    f_expr : Variable
        The Variable containing the resulting array.

    shape : list of Variables
        A list describing the Variables which dictate the size of the array in each dimension.
    """
    __slots__ = ('_c_expr', '_f_expr', '_shape')
    _attribute_nodes = ('_c_expr', '_f_expr', '_shape')

    def __init__(self, c_expr, f_expr, shape = None):
        self._c_expr = c_expr
        self._f_expr = f_expr
        self._shape = shape
        super().__init__()

    @property
    def c_pointer(self):
        """
        The Variable containing the C pointer.

        The Variable of dtype BindCPointer which contains the C pointer.
        """
        return self._c_expr

    @property
    def f_array(self):
        """
        The Variable containing the resulting array.

        The Variable where the array pointer will be stored.
        """
        return self._f_expr

    @property
    def shape(self):
        """
        A list of the sizes of the array in each dimension.

        A list describing the Variables which are passed as arguments, in order to
        determine the size of the array in each dimension.
        """
        return self._shape

class DeallocatePointer(Deallocate):
    """
    Represents memory deallocation for memory only stored in a pointer.

    Represents memory deallocation for memory only stored in a pointer. Usually
    `deallocate` is not called on pointers so as not to delete the target values
    however this capability is necessary in the wrapper.

    Parameters
    ----------
    variable : pyccel.ast.core.Variable
        The typed variable (usually an array) that needs memory deallocation.
    """
    __slots__ = ()

class BindCSizeOf(PyccelFunction):
    """
    Represents a call to a function which can calculate the size of an object in bits.

    Represents a call to a function which can calculate the size of an object in bits.

    Parameters
    ----------
    element : TypedAstNode
        The object whose type should be determined.
    """
    __slots__ = ()
    _class_type = PythonNativeInt()
    _shape = None

    def __init__(self, element):
        super().__init__(element)

class C_NULL_CHAR(TypedAstNode):
    """
    A class representing the C_NULL_CHAR character from the iso_c_binding module.

    A class representing the C_NULL_CHAR character from the iso_c_binding module.
    This object should be appended to strings before returning them from Fortran
    to C.
    """
    __slots__ = ()
    _class_type = StringType()
    _shape = (LiteralInteger(1),)
    _attribute_nodes = ()

c_malloc = FunctionDef('c_malloc', (FunctionDefArgument(Variable(PythonNativeInt(), 'size')),),
                        (), FunctionDefResult(Variable(BindCPointer(), 'ptr')))
