# Code Generation stage

The code generation stage is specific to the target language.
The files which describe this stage can be found in the folder [pyccel.codegen.printing](../pyccel/codegen/printing).

This stage exists to print the Pyccel AST in the syntax of the target language.
Each target language has its own file containing a class which inherits from [pyccel.codegen.printing.codeprinter.CodePrinter](../pyccel/codegen/printing/codeprinter.py).

The entry point for the class `CodePrinter` is the function `doprint`.
The key lines of the function `doprint` are the call to `self._print(expr)` and the call to `self._format_code(lines)`.

## `_print`

The `_print` function internally calls a function named `_print_X`, where `X` is the type of the object.
These functions must have the form:
```python
def _print_ClassName(self, stmt):
    ...
    return Y
```
where `Y` must be a string.
Each of these `_print_X` functions should internally call the `_print` function on each of the elements of the object to obtain strings which can be combined to create a string describing the current object in the target language.
It can be tempting to skip some of these `_print` calls, especially for basic types such as literals.
However it is very important to use these functions as much as possible.
This is important for several reasons:
1.  It ensures that the same conventions are used throughout the generated code
2.  It ensures that code details are not forgotten
3.  It makes refactoring much simpler

For example, it is sometimes necessary to print a `0`.
It is very tempting to just use `'0'` directly, however this would mean that the precision of the integer would not be printed.
In some languages (e.g. Fortran) not specifying the precision in literals can have unintended consequences on the final result.

## `_format_code`

The `_format_code` function is run on the string generated by the `_print` function in order to format the code.
In this conntext formatting the code means:
1.  Ensure that the indenting is correct to generate readable (and in the case of the python printer, valid) code.
2.  Wrap any lines which are too long to be readable. The wrapping aims to split the line in a readable place, not just after a given number of characters (e.g. we aim to not split strings, if this is unavoidable we aim to not split word).

## Language-specific semantics

Although the semantic stage aims to produce code which is low-level enough to be written as-is, some languages have specific requirements which require further changes.
The possiblity of adding an additional language-specific semantic stage has been discussed, but currently these changes are made in the code generation stage.

This separation has not always been done with as much thought as necessary so improvements could be made.

## Adding variables

Although the semantic layer usually takes care of creating all variables necessary it is occasionally necessary to create a variable in the codegen stage (e.g. The iteration index used when prining an array).
Where possible this should be done using the function [`Scope.get_temporary_variable`](../pyccel/parser/scope.py).
If for some reason it is not possible to use this function (e.g. because a `DottedVariable` must be created) then it is important to use `Scope.insert_variable` to insert the variable into the scope.
This ensures that it will be correctly declared.

## Declarations

In order to ensure all variables are correctly declared, declarations are always the last object that is printed.
The code snippet is then inserted into the final string in the correct position (near the beginning).
The declarations are provided by the `declarations` property of the classes `Module` and `FunctionDef` the only exception to this rule is the case of external variables.

## Imports

## Loop unravelling



## C-specific problems

### Use of C pointers

In order to implement certain concepts in C it is important to use pointers.
These concepts include returned variables and optional variables.
This means that all print functions in the code must be able to correctly handle both pointers and non-pointers.
In order to simply the developer's job and allow them to focus on the specifics of the AST element they are implementing, rather than the pointers `_print_Variable` and other similar print functions always print the value of the object.
This is true even if the object is stored in a pointer (i.e. `(*var)` is printed).
If an address is required then the object must be wrapped in the [`pyccel.ast.c_concepts.ObjectAddress`](../pyccel/ast/c_concepts.py) class.

Although this construction ensures that valid code can be written easily, unless care is taken unidiomatic code will be produced (e.g. `(*var).shape` instead of `var->shape`).
It is therefore very important to use the AST to represent class objects, so that the pointer differentiation can be handled in as few functions as possible.
The following objects are very useful for this purpose:
-   `DottedVariable` : Used to access member variables of a class. It may be necessary to create a `DottedVariable` to print an object such as a member of the `t_ndarray` class.
-   `NumpyArraySize` : The size of an array in a given dimension
-   `PyccelArraySize` : The total size of an array

Finally it is also important to mention the function `stored_in_c_pointer`, which indicates whether or not its argument is stored in a pointer in the C code.
If code relies on the AST nodes described above the use of this function should be limited to the printing of a few low level objects.
However it is occasionally useful (especially when printing the wrapper), so it is important to be aware of this function.

### Nested objects

### Multiple-returns

### Optional arguments

### Arrays

## Fortran-specific problems

### 0-based arrays

Unlike in the majority of coding languages, Fortran array indexes do not have to start from 0.
In fact, the default start index is 1.
As a result this needs to be taken into consideration when writing code.

There are two possibilities to handle this; either we can modify every index by adding 1, or we can define our arrays in Fortran with syntax which ensures that the indexes start from 0.
In Pyccel we have chosen the latter option.
It is therefore very important to think about this when allocating arrays or pointers.

### Ordering

## Python-specific problems
