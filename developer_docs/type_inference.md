# Type inference

:warning: Some of this documentation describes developments that are being added to Pyccel at the moment. For information about the previous state see the description in issue #1487 or contact Emily on the discord.

Type inference, in other words deducing the type of an object is one of the keystones of Pyccel. It is what allows us to correctly declare our variables in the generated code and thereby obtain the expected results. The majority of the type inference is found in the semantic stage, however there are a few objects whose type cannot be deduced. The type of these objects is inferred from type annotations. As such there are a few steps of the type inference which occur in the syntactic stage.

## Syntactic Stage

There are two types of type annotations that are found in Pyccel-compatible code. The first, simplest case is the case of Python type annotations. E.g:
```python
a : int
```
The annotations on these objects are parsed by Python's `ast` module. This ensures that the code is syntactically correct. The object can be visited in the same way as any other node in the code.

This treatment is very simple, however it is not trivial to identify the result as a type annotation. As a result the resulting `PyccelSymbol`/`DottedName`/etc is stored as an element of the `dtypes` property of the class `pyccel.ast.type_annotations.SyntacticTypeAnnotation`. This allows all type annotations to be handled in the same function in the semantic stage regardless of whether they are function argument annotations, variable annotations, or something else.

The second type of annotation is annotations in strings. E.g:
```python
a : 'int'
```
This kind of annotation is equally important as it allows us to add extra information (e.g. `'const int'`) or refer to types which are not fully initialised (e.g. passing as a class method argument an instance of the same class).

In order to ensure that the syntax inside the string is correct, the expression is parsed immediately in the syntactic stage. This is done using the package [`textx`](http://textx.github.io/textX/3.1/). This tool creates a parser for a language described by a file. The files describing the type language can be found in the folder `pyccel/parser/grammar/`. The results generated by `textx` are stored in auto-generated classes or classes defined in the folder `pyccel/parser/syntax/`. As these instances are created by `textx` we do not have full control over their contents. Notably this means that we cannot pickle the instance (pickling is used for header files to accelerate compilation). It is therefore important to transfer this information to a new class. The `pyccel.ast.type_annotations.SyntacticTypeAnnotation` class is used for this purpose. It stores all the information described by either a `UnionTypeStmt` or a `Type` (see `pyccel/parser/grammar/headers.tx` for definitions).

Therefore at the end of the syntactic stage, the syntax of all type annotations has been verified, and the raw information is stored in a `pyccel.ast.type_annotations.SyntacticTypeAnnotation` object ready to be treated in the semantic stage.

## Semantic Stage

The semantic stage handles two types of type inference:
1.  Inferring types from type annotations.
2.  Inferring types from assignments.

Each of these cases must be handled in different ways however there are many unifying factors which come into play once the types are deduced. Namely the verification that the types are coherent (i.e. that we are not changing the type of an existing variable), and the creation of any necessary variables. Both of these are usually handled by the function `pyccel.parser.semantic.SemanticParser._assign_lhs_variable`.

### Inferring types from type annotations

After the syntactic stage any type annotations should be stored in a `pyccel.ast.type_annotations.SyntacticTypeAnnotation`. The critical function is therefore `pyccel.parser.semantic.SemanticParser._visit_SyntacticTypeAnnotation`. This function converts the annotation to either a `pyccel.ast.type_annotations.TypeAnnotation` or a `pyccel.ast.type_annotations.FunctionTypeAnnotation`. Union types exist in Python. As a result a type annotation may indicate more than one type. E.g:
```python
a : (int | float)
```
In order to make it easier to handle the result of `pyccel.parser.semantic.SemanticParser._visit_SyntacticTypeAnnotation`, the `TypeAnnotation`s and `FunctionTypeAnnotation`s are always stored in a `pyccel.ast.type_annotations.UnionTypeAnnotation`, even if there is only one possible type.

These objects contain all the information necessary to create a Variable from a type annotation.

### Inferring types from assignments

When assignments occur in the code types must also be inferred. This allows new variables to be declared implicitly, and also enables us to verify that the types of existing variables do not change. In this case the type inference is done via the AST nodes. Each node contains the logic necessary to deduce its type information from the arguments passed to it. The resulting object, which is found on the right hand side of an assignment can be used to verify or define the type of the object on the left hand side of the assignment.
